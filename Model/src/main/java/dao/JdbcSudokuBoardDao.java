package dao;

import exceptions.ModelDaoReadException;
import exceptions.ModelDaoWriteException;
import exceptions.ModelDatabaseCreateException;
import exceptions.ModelioException;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.List;
import sudoku.SudokuBoard;
import sudoku.solver.BacktrackingSudokuSolver;

public class JdbcSudokuBoardDao implements Dao<SudokuBoard> {
    private Statement statement;
    private Connection con;
    private String boardName;
    private SudokuBoard initialBoard;
    private String urlConnection;

    /**
     * Constructor of dbDao.
     * @param dbname name of database.
     */
    public JdbcSudokuBoardDao(String dbname) {
        urlConnection = "jdbc:derby:./target/" + dbname + ";create=true";
        createDatabase();
    }

    /**
     * Creates database.
     */
    private void createDatabase() {
        try (Connection con = DriverManager.getConnection(urlConnection)) {
            initializeConnection(con);
            try {
                con.beginRequest();
                statement.execute("CREATE TABLE boards "
                        + "(id INT PRIMARY KEY GENERATED BY DEFAULT "
                        + "AS IDENTITY (START WITH 1, INCREMENT BY 1)"
                        + ",boardName VARCHAR(255))");
                statement.execute("CREATE TABLE fields "
                        + "(id INT PRIMARY KEY GENERATED BY DEFAULT "
                        + "AS IDENTITY (START WITH 1, INCREMENT BY 1),"
                        + "boardId INT REFERENCES boards(id),x INT,y INT,fvalue INT,"
                        + "disabled BOOLEAN)");
                finalizeConnection(con);
            } catch (SQLException e) {
                rollbackAndClose();
            }
        } catch (SQLException e) {
            throw new ModelDatabaseCreateException("databasecreate.exception", new Throwable());
        }
    }

    /**
     * Reads two boards from database.
     * @param boardName name of baord to save.
     * @return list of current and initial boards
     * @throws ModelioException Database rollback exception.
     * @throws ModelDaoReadException Database read exception.
     */
    public List<SudokuBoard> read(String boardName) {
        try (Connection con = DriverManager.getConnection(urlConnection)) {
            this.boardName = boardName;
            this.initialBoard = new SudokuBoard(new BacktrackingSudokuSolver());
            ArrayList<SudokuBoard> list = new ArrayList<>();
            initializeConnection(con);
            con.beginRequest();
            list.add(read());
            list.add(this.initialBoard);
            finalizeConnection(con);
            return list;
        } catch (SQLException e) {
            rollbackAndClose();
            throw new ModelDaoReadException("databaseread.exception", new Throwable());
        }
    }

    /**
     * Read T object from file.
     *
     * @return T
     */
    @Override
    public SudokuBoard read() {
        try {
            String id = "";
            SudokuBoard databaseBoard = new SudokuBoard(new BacktrackingSudokuSolver());
            try (ResultSet rs = statement.executeQuery("SELECT * FROM boards "
                    + "WHERE boardName='" + this.boardName + "'")) {
                while (rs.next()) {
                    if (rs.getString("boardName").equals(this.boardName)) {
                        id = rs.getString("id");
                    }
                }
            }
            if (id.equals("")) {
                con.rollback();
                con.close();
                throw new ModelDaoReadException("databasenoinfo.exception", new Throwable());
            }
            try (ResultSet rs2 = statement.executeQuery("SELECT * FROM fields "
                    + "WHERE boardId=" + id)) {
                while (rs2.next()) {
                    databaseBoard.set(Integer.parseInt(rs2.getString("x")),
                            Integer.parseInt(rs2.getString("y")),
                            Integer.parseInt(rs2.getString("fvalue")));
                    if (rs2.getString("disabled").equals("true")) {
                        this.initialBoard.set(Integer.parseInt(rs2.getString("x")),
                                Integer.parseInt(rs2.getString("y")),
                                Integer.parseInt(rs2.getString("fvalue")));
                    }
                }
            }
            return databaseBoard;
        } catch (SQLException e) {
            rollbackAndClose();
            throw new ModelDaoReadException("databaseread.exception", e);
        }
    }

    /**
     * Writes two boards to database.
     * @param current current sudokuboard obj.
     * @param initial initial sudokuboard obj.
     * @param boardName name of baord to save.
     * @throws ModelioException Database rollback error exception.
     * @throws ModelDaoWriteException Database write exception.
     */
    public void write(SudokuBoard current, SudokuBoard initial, String boardName) {
        try (Connection con = DriverManager.getConnection(urlConnection)) {
            this.boardName = boardName;
            this.initialBoard = initial;
            initializeConnection(con);
            con.beginRequest();
            write(current);
            finalizeConnection(con);
        } catch (SQLException e) {
            rollbackAndClose();
            throw new ModelDaoWriteException("databasewrite.exception", new Throwable());
        }
    }

    /**
     * Write (save) T object to file.
     *
     * @param obj object type T which should be saved to file
     * @throws ModelioException Database rollback error exception.
     * @throws ModelDaoWriteException Database write exception.
     */
    @Override
    public void write(SudokuBoard obj) {
        try {
            String id = "";
            try (ResultSet exists = statement.executeQuery("SELECT * FROM boards "
                    + "WHERE boardName='" + this.boardName + "'")) {
                if (exists.next()) {
                    con.rollback();
                    con.close();
                    throw new ModelDaoWriteException("databasename.exception", new Throwable());
                }
            }
            statement.execute("INSERT INTO boards(boardName) VALUES ('" + this.boardName + "')");
            try (ResultSet rs = statement.executeQuery("SELECT * FROM boards "
                    + "WHERE boardName='" + this.boardName + "'")) {
                if (rs.next()) {
                    id = rs.getString("id");
                }
            }
            int idNum = Integer.parseInt(id);
            for (int i = 0; i < 9; i++) {
                for (int j = 0; j < 9; j++) {
                    statement.execute("INSERT INTO fields(boardId,x,y,fvalue,disabled) VALUES "
                            + "(" + idNum + "," + i + "," + j + "," + obj.get(i, j) + ","
                            + (this.initialBoard.get(i, j) == obj.get(i, j)) + ")");
                }
            }
        } catch (SQLException e) {
            rollbackAndClose();
            throw new ModelDaoWriteException("databasewrite.exception", e);
        }
    }

    @Override
    public void close() throws ModelioException {
    }

    /**
     * Lists all saved sudokuboard names.
     *
     * @return List names of all saved sudokuboards.
     */
    public List<String> allSudokuBoardsSaved() {
        List<String> list = new ArrayList<>();
        try (Connection con = DriverManager.getConnection(urlConnection)) {
            initializeConnection(con);
            con.beginRequest();
            try (ResultSet rs = statement.executeQuery("SELECT boardName FROM boards")) {
                while (rs.next()) {
                    list.add(rs.getString("boardName"));
                }
            }
            finalizeConnection(con);
            return list;
        } catch (SQLException e) {
            rollbackAndClose();
            throw new ModelDatabaseCreateException("databasecreate.exception", new Throwable());
        }
    }

    /**
     * Initialize connection with database.
     * @param con established connection.
     * @throws SQLException sqlexception.
     */
    private void initializeConnection(Connection con) throws SQLException {
        this.con = con;
        statement = con.createStatement();
        con.setAutoCommit(false);
    }

    /**
     * Closes connection with database.
     * @param con established connection.
     * @throws SQLException sqlexception.
     */
    private void finalizeConnection(Connection con) throws SQLException {
        con.commit();
        con.endRequest();
    }

    /**
     * Check if connection is closed.
     * @return conEstablishment
     * @throws SQLException sqlexception.
     */
    public boolean isConnectionClosed() throws SQLException {
        return con.isClosed();
    }

    /**
     * Method rollback transaction and close connection.
     */
    private void rollbackAndClose() throws ModelioException {
        try {
            con.rollback();
            con.close();
        } catch (SQLException throwables) {
            throw new ModelioException("databaserollback.exception", throwables);
        }
    }
}
